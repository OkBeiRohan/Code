/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Binary Counter on Button Press
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 ******************************************************************************
 * Program to use on-board LEDs (PC6, PB13, PB14, PB15) as a binary counter.
 */

#include <stdint.h>

void init();
void config();
void counter(uint32_t *, uint32_t *, uint32_t *);
void trigger_buzzer(uint32_t *, uint8_t);
void delay(uint32_t);

uint32_t *ptr_GPIOA_IDR, *ptr_RCC_AHB1ENR, *ptr_GPIOC_MODER, *ptr_GPIOB_MODER, *ptr_GPIOC_ODR, *ptr_GPIOB_ODR;

int main(void)
{
  init();
  config();

  counter(ptr_GPIOC_ODR, ptr_GPIOB_ODR, ptr_GPIOA_IDR);
}

void init()
{
  /**
   * To blink LED, enable the clock for the General Purpose I/O (GPIO) ports C and B.
   * Base address of the clock enable register (RCC_AHB1ENR) = 0x4002 3800
   * Offset address = 0x30
   * Address = 0x4002 3830
   * For LED1, Port PC6 have to be enabled. For that enable GPIOCEN bit. (At 2nd position)
   * For LED2, LED3, and LED4, Port PB13, PB14, and PB15 have to be enabled. For that enable GPIOBEN bit. (At 1st position)
   */
  ptr_RCC_AHB1ENR = (uint32_t *)0x40023830;

  /**
   * Set the mode of the pin PC9 to output mode. (For buzzer)
   * Base address of the GPIO Port C Mode Register (GPIOC) = 0x4002 0800
   * Offset address of the mode register = 0x00
   * Address = 0x4002 0800
   * For buzzer, Pin PC6 have to be set to output mode. For that set GPIOC6 bit. (At 12th position)
   * Output Mode = 01
   */
  ptr_GPIOC_MODER = (uint32_t *)0x40020800;

  /**
   * Set the mode of the pins PC6, PB13, PB14, and PB15 to output mode.
   * Base address of the GPIO Port C Mode Register (GPIOC) = 0x4002 0800
   * Offset address of the mode register = 0x00
   * Address = 0x4002 0800
   * For LED1, Pin PC6 have to be set to output mode. For that set GPIOC6 bit. (At 12th position)
   *
   * Base address of the GPIO Port B Mode Register (GPIOB) = 0x4002 0400
   * For LED2, Pin PB13 have to be set to output mode. For that set GPIOB13 bit. (At 26th position)
   * For LED3, Pin PB14 have to be set to output mode. For that set GPIOB14 bit. (At 28th position)
   * For LED4, Pin PB15 have to be set to output mode. For that set GPIOB15 bit. (At 30th position)
   *
   * Output Mode = 01
   */
  ptr_GPIOB_MODER = (uint32_t *)0x40020400;

  /**
   * Change the output bit through the port PC6 using the Output Data Register (ODR) (For buzzer)
   * Base address of the GPIO port C = 0x4002 0800
   * Offset address of the mode register = 0x14
   * Address = 0x4002 0814
   * For turning the buzzer ON, reset the ODR6 bit. For turning it OFF, set the ODR6 bit
   *
   * Change the output bit through the ports using the Output Data Register (ODR)
   * Base address of the GPIO port C = 0x4002 0800
   * Base address of the GPIO port B = 0x4002 0400
   * Offset address of the mode register = 0x14
   * Address for port C= 0x4002 0814
   * Address for port B= 0x4002 0414
   * For turning the LED ON, reset the ODR6 bit. For turning it OFF, set the ODR6 bit
   */
  ptr_GPIOC_ODR = (uint32_t *)0x40020814;
  ptr_GPIOB_ODR = (uint32_t *)0x40020414;

  /**
   * Read the input bit through the port PB7 using the Input Data Register (IDR)
   * Base address of the GPIO port B = 0x4002 0400
   * Offset address of the mode register = 0x10
   * Address = 0x4002 0010
   * For reading the input bit, read the IDR7 bit. (At 7th position)
   */
  ptr_GPIOA_IDR = (uint32_t *)0x40020410;
}

void config()
{
  *ptr_RCC_AHB1ENR |= (1 << 2); // Set bit 2 (GPIOCEN)
  *ptr_RCC_AHB1ENR |= (1 << 1); // Set bit 1 (GPIOBEN)

  *ptr_GPIOC_MODER |= (1 << 18);  // Set bit 18
  *ptr_GPIOC_MODER &= ~(1 << 19); // Clear bit 19

  *ptr_GPIOC_MODER |= (1 << 12);  // Set bit 12
  *ptr_GPIOC_MODER &= ~(1 << 13); // Clear bit 13

  *ptr_GPIOB_MODER |= (1 << 26);  // Set bit 26
  *ptr_GPIOB_MODER &= ~(1 << 27); // Clear bit 27
  *ptr_GPIOB_MODER |= (1 << 28);  // Set bit 28
  *ptr_GPIOB_MODER &= ~(1 << 29); // Clear bit 29
  *ptr_GPIOB_MODER |= (1 << 30);  // Set bit 30
  *ptr_GPIOB_MODER &= ~(1 << 31); // Clear bit 31

  /**
   * SW1 is connected to pin PB7. Set the mode of the pin PB7 to input mode.
   * Base address of the GPIO Port B Mode Register (GPIOB) = 0x4002 0400
   * Offset address of the mode register = 0x00
   * Address = 0x4002 0000
   * For SW1, Pin PB7 have to be set to input mode
   * Input Mode = 00
   */

  *ptr_GPIOB_MODER &= ~(1 << 15); // Clear bit 15
  *ptr_GPIOB_MODER &= ~(1 << 14); // Clear bit 14
}

/**
 * Function to count number
 * @param ptr_GPIOC_ODR Pointer to the GPIOC_ODR register
 * @param ptr_GPIOB_ODR Pointer to the GPIOB_ODR register
 * @param ptr_GPIOA_IDR Pointer to the GPIOA_IDR register
 * @return None
 */
void counter(uint32_t *ptr_GPIOC_ODR, uint32_t *ptr_GPIOB_ODR, uint32_t *ptr_GPIOA_IDR)
{
  uint8_t led_pattern = 0x00;

  /**
   * Start the counter and wait for button
   */
  while (1)
  {
    /**
     * Trigger the buzzer
     */

    if (!(*ptr_GPIOA_IDR & (1 << 7)))
    {
      led_pattern++;
      if (led_pattern == 0x0F)
      {
        /**
         * Initializing Sound
         */
        trigger_buzzer(ptr_GPIOC_ODR, 1);
        delay(50);
        trigger_buzzer(ptr_GPIOC_ODR, 0);
        delay(100);
        trigger_buzzer(ptr_GPIOC_ODR, 1);
        delay(100);
        trigger_buzzer(ptr_GPIOC_ODR, 0);
        delay(50);
        trigger_buzzer(ptr_GPIOC_ODR, 1);
        delay(50);
        trigger_buzzer(ptr_GPIOC_ODR, 0);
      }
      trigger_buzzer(ptr_GPIOC_ODR, 1);
      delay(10);
      trigger_buzzer(ptr_GPIOC_ODR, 0);
      delay(100);
    }

    if (led_pattern & (0x01 << 0))
    {
      *ptr_GPIOC_ODR &= ~(0x01 << 6); // Turn LED1 ON
    }
    else
    {
      *ptr_GPIOC_ODR |= (0x01 << 6); // Turn LED1 OFF
    }

    if (led_pattern & (0x01 << 1))
    {
      *ptr_GPIOB_ODR &= ~(0x01 << 15); // Turn LED2 ON
    }
    else
    {
      *ptr_GPIOB_ODR |= (0x01 << 15); // Turn LED2 OFF
    }

    if (led_pattern & (0x01 << 2))
    {
      *ptr_GPIOB_ODR &= ~(0x01 << 14); // Turn LED3 ON
    }
    else
    {
      *ptr_GPIOB_ODR |= (0x01 << 14); // Turn LED3 OFF
    }

    if (led_pattern & (0x01 << 3))
    {
      *ptr_GPIOB_ODR &= ~(0x01 << 13); // Turn LED4 ON
    }
    else
    {
      *ptr_GPIOB_ODR |= (0x01 << 13); // Turn LED4 OFF
    }
  }
}

/**
 * Function to trigger the buzzer
 * @param ptr_GPIOC_ODR Pointer to the GPIOC_ODR register
 * @return None
 */
void trigger_buzzer(uint32_t *ptr_GPIOC_ODR, uint8_t buzzer_state)
{
  if (buzzer_state == 0)
  {
    *ptr_GPIOC_ODR &= ~(1 << 9);
  }
  else
  {
    *ptr_GPIOC_ODR |= (1 << 9);
  }
}

/**
 * Function to generate delay
 * @param delay_ms Delay in milliseconds
 * @return None
 */
void delay(uint32_t delay_ms)
{
  uint32_t counter;
  for (counter = 0; counter < (delay_ms * 1000); counter++)
    ;
}
