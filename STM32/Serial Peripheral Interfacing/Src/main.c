/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Serial Peripheral Interfacing (SPI)
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <common.h>

void spi_master_config(void);
void spi_gpio_config(void);
void spi_slave_config(void);
void communicate(uint32_t);
void send_data(uint32_t);
void led_config(void);
void button_config(void);
void await_button_press(void);
uint32_t receive_data(uint32_t);

int main(void)
{
    uint32_t counter = 0;

    lcd_init(BIT_4_MODE);

    lcd_print(0, 0, "Configuring");
    lcd_print(0, 1, "SPI Master");
    spi_master_config();
    lcd_print(0, 1, "SPI Slave ");
    spi_slave_config();
    lcd_print(0, 1, "SPI GPIO  ");
    spi_gpio_config();
    lcd_print(0, 1, "LED       ");
    led_config();
    lcd_print(0, 1, "Button    ");
    button_config();

    set_lcd_mode(CLEAR_SCREEN);
    lcd_print(0, 0, "SPI:");
    lcd_print(0, 1, "RX:      TX:");

    while (1)
    {
        communicate(counter);
        counter++;
        if (counter == 0xFF)
        {
            counter = 0;
        }
    }
}

void spi_master_config()
{
    RCC->APB2ENR |= (1 << 12);        // Enable SPI1 clock
    SPI1->CR1 |= (1 << 2);            // Master Enable
    SPI1->CR1 |= (1 << 0) | (1 << 1); // CPHA=1, 	CPOL=1
    SPI1->CR1 &= ~(7 << 3);           // clear baudrate
    SPI1->CR1 |= (3 << 3);            // set baudrate by fclk/16
    SPI1->CR1 &= ~(1 << 7);           // MSB bit first
    SPI1->CR1 |= (1 << 9);            // Software slave enable
    SPI1->CR1 |= (1 << 8);            // Internal slave select
    SPI1->CR1 &= ~(1 << 10);          // Full duplex mode
    SPI1->CR1 &= ~(1 << 11);          // 8-bit data format
    SPI1->CR1 &= ~(1 << 13);          // CRC next
    SPI1->CR1 &= ~(1 << 15);          // unidirectional mode
    SPI1->CR1 |= (1 << 6);            // SPI Enable
}

void spi_gpio_config()
{
    /**
     * SPI 1 GPIO pins
     * PA5 --> SCK 21
     * PA6 --> MISO 22
     * PA7 --> MOSI  23
     */
    RCC->AHB1ENR |= (1 << 0);                               // PortA Clock Enable
    GPIOA->MODER &= ~((3 << 10) | (3 << 12) | (3 << 14));   // clear PA5-PA6
    GPIOA->MODER |= (2 << 10) | (2 << 12) | (2 << 14);      // Alternate mode
    GPIOA->OTYPER &= ~(7 << 5);                             // push-pull for PA5-PA7;
    GPIOA->OSPEEDR &= ~((3 << 10) | (3 << 12) | (3 << 14)); // clear speed select
    GPIOA->OSPEEDR |= (2 << 10) | (2 << 12) | (2 << 14);    // High speed PA5-PA7
    GPIOA->AFR[0] &= ~(0xFFF << 20);
    GPIOA->AFR[0] |= (0x555 << 20); // SPI alternate function PA5-PA7
    /**
     * SPI 3 GPIO pins
     * PB3 --> SCK 55
     * PB4 --> MISO 56
     * PB5 --> MOSI 57
     */
    RCC->AHB1ENR |= (1 << 1); // PortB Clock Enable
    GPIOB->MODER &= ~((3 << 6) | (3 << 8) | (3 << 10));
    GPIOB->MODER |= (2 << 6) | (2 << 8) | (2 << 10);      // Alternate mode
    GPIOB->OTYPER &= ~(7 << 3);                           // push-pull for PB3-PB5;
    GPIOB->OSPEEDR &= ~((3 << 6) | (3 << 8) | (3 << 10)); // clear speed select
    GPIOB->OSPEEDR |= (2 << 6) | (2 << 8) | (2 << 10);    // High speed PB3-PB5
    GPIOB->AFR[0] &= ~(0xFFF << 12);                      // clear alternate function
    GPIOB->AFR[0] |= (0x666 << 12);                       // SPI alternate function PB3-PB5
}

void spi_slave_config()
{
    RCC->APB1ENR |= (1 << 15);        // SPI3 clock enable
    SPI3->CR1 &= ~(1 << 2);           // Slave mode enable
    SPI3->CR1 |= (1 << 0) | (1 << 1); // CPHA=1, 	CPOL=1
    SPI3->CR1 &= ~(7 << 3);           // clear baudrate
    SPI3->CR1 |= (3 << 3);            // set baudrate by fclk/16
    SPI3->CR1 &= ~(1 << 7);           // MSB bit first
    SPI3->CR1 |= (1 << 9);            // Software slave enable
    SPI3->CR1 &= ~(1 << 8);           // clear Internal slave select
    SPI3->CR1 &= ~(1 << 10);          // Full duplex mode
    SPI3->CR1 &= ~(1 << 11);          // 8-bit data format
    SPI3->CR1 &= ~(1 << 13);          // CRC next
    SPI3->CR1 &= ~(1 << 15);          // unidirectional mode
    SPI3->CR1 |= (1 << 6);            // SPI Enable
}

void led_config()
{
    RCC->AHB1ENR |= (1 << 2);   // Enable PORT C clock
    GPIOC->MODER &= ~(3 << 12); // PC6 LED bit 12 and 13
    GPIOC->MODER |= (1 << 12);  // Pc6 as output
    GPIOC->OTYPER &= ~(1 << 6); // push pull at PC6
    // GPIOC->OSPEEDR &= ~(3<<24);	//low speed
    GPIOC->ODR &= ~(1 << 6); // low PC6
}

void button_config()
{
    RCC->AHB1ENR |= (1 << 0);   // PORTA clock enable
    GPIOA->MODER &= ~(3 << 30); // PA15 as input
    // GPIOA->PUPDR &= ~(3<<30);	// no pull up/down
}

void await_button_press()
{
    lcd_print(4, 0, "Press Button");
    while (GPIOA->IDR & (1 << 15))
        ; // Wait until button is pressed
}

void communicate(uint32_t value)
{
    uint32_t rec = 0;
    await_button_press();
    lcd_print(4, 0, "Sending     ");
    lcd_print_int(12, 1, value, 1);
    send_data(value);
    lcd_print(4, 0, "Receiving   ");
    rec = receive_data(value);
    lcd_print_int(3, 1, rec, 1);
}

void send_data(uint32_t data)
{
    lcd_print(4, 0, "Awaiting    ");
    while (!(SPI1->SR & (1 << 1)))
        ;            // Wait until TX buffer is empty
    SPI1->DR = data; // Send data
    lcd_print(4, 0, "Sending     ");
    if (SPI1->DR != data)
    {
        lcd_print(4, 0, "Data Loss   ");
        delay(100);
    }
    while (!(SPI1->SR & (1 << 1)))
        ; // Wait until TX buffer is empty
    lcd_print(4, 0, "Sent        ");
    if (SPI1->SR & (1 << 3))
    {
        lcd_print(4, 0, "Overrun     ");
        delay(100);
    }
    if (SPI1->SR & (1 << 4))
    {
        lcd_print(4, 0, "Mode Fault  ");
        delay(100);
    }
    if (SPI1->SR & (1 << 6))
    {
        lcd_print(4, 0, "CRC Error   ");
        delay(100);
    }
}

uint32_t receive_data(uint32_t check_data)
{
    lcd_print(4, 0, "Awaiting    ");
    while (!(SPI3->SR & (1 << 0)))
        ; // Wait until RX buffer is not empty
    lcd_print(4, 0, "Received    ");
    if (SPI3->DR != check_data)
    {
        lcd_print(4, 0, "Data Loss   ");
        delay(100);
    }
    else
    {
        GPIOC->ODR ^= (1 << 6); // Toggle LED
    }
    if (SPI3->SR & (1 << 3))
    {
        lcd_print(4, 0, "Overrun     ");
        delay(100);
    }
    if (SPI3->SR & (1 << 4))
    {
        lcd_print(4, 0, "Mode Fault  ");
        delay(100);
    }
    if (SPI3->SR & (1 << 6))
    {
        lcd_print(4, 0, "CRC Error   ");
        delay(100);
    }
    return SPI3->DR;
}
