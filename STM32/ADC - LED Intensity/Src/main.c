/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : LED Intensity control
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <common.h>

#define TIM_FREQ 16000000

uint32_t pot_value = 0;
double pot_value_percent = 0;

void init();
void check_pot();
void set_duty_cycle(uint32_t, uint32_t, uint32_t);

int main(void)
{
	init();

	while (1)
	{
		check_pot();
	}
}

void init()
{
	lcd_init(BIT_4_MODE);
	lcd_print(0, 0, "LED Intensity");
	lcd_print(3, 1, "Percent");
	RCC->AHB1ENR |= RCC_AHB1ENR_GPIOCEN; // Enable GPIOC clock
	set_analog(GPIOC, 2);				 // Set PC2 as analog (POT1)
	set_alternate(GPIOC, 6);			 // Set PC6 to alternate function
	GPIOC->AFR[0] |= (1 << 25);			 // Links AFRL bits to AF of PC6 (24 and 27 bits to 0010)

	RCC->APB2ENR |= RCC_APB2ENR_ADC1EN; // Enable ADC1 clock
	ADC1->CR2 = 0;						// Disable ADC1
	ADC1->SQR3 |= (0xC << 0);			// Set channel 12 (PC2) as first conversion in regular sequence
	ADC1->SQR1 = 0;						// Set length of regular sequence to 1 conversion
	ADC1->CR2 = 1;						// Enable ADC1

	RCC->APB1ENR |= (1 << 1); // Enable TIM3 clock
	TIM3->PSC = 0;			  // Prescaler value
	TIM3->CNT = 0;
	// TIM3->ARR = 1000 - 1;  // Auto-reload value
	TIM3->CCMR1 |= (1 << 3); // Set output compare 1 mode to PWM mode 1
	TIM3->CCMR1 |= (6 << 4); // PWM mode 1
	TIM3->CCER |= (3 << 0);	 // Capture/Compare 1 output enable
	TIM3->CR1 |= (1 << 0);	 // Enable TIM3
}

void check_pot()
{
	pot_value_percent = (pot_value / 4059.0) * 100.0;
	if ((uint32_t)pot_value_percent < 100)
	{
		lcd_print(2, 1, " ");
	}
	lcd_print_int(0, 1, (uint32_t)pot_value_percent, 1); // Print ADC value

	ADC1->CR2 |= 1 << 30; // Start conversion
	while (!(ADC1->SR & 1 << 1))
		;				  // Wait for conversion to complete
	pot_value = ADC1->DR; // Read conversion pot_value

	set_duty_cycle(10000, (uint32_t)pot_value_percent, 1); // Set duty cycle

	ADC1->SR &= ~(1 << 1); // Clear EOC flag
}

void set_duty_cycle(uint32_t freq, uint32_t duty_cycle, uint32_t channel)
{
	TIM3->ARR = (TIM_FREQ / freq) - 1; // Set auto-reload value
	if (duty_cycle > 100)
	{
		duty_cycle = 100;
	}
	TIM3->CCR1 = (duty_cycle * ((TIM3->ARR) + 1)) / 100; // Set duty cycle
}
