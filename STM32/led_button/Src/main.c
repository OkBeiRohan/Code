/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Turn on respective LED on button press
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>

void init();
void config();
void start();
void set_led(uint8_t);
void toggle_buzzer(uint8_t);
void delay(uint32_t);

uint32_t *ptr_AHB1ENR, *ptr_GPIOA_MODER, *ptr_GPIOB_MODER, *ptr_GPIOC_MODER, *ptr_GPIOA_IDR, *ptr_GPIOB_IDR, *ptr_GPIOB_ODR, *ptr_GPIOC_ODR;

int main(void)
{
  init();
  config();
  start();
}

void init()
{
  ptr_AHB1ENR = (uint32_t *)0x40023830;     // Address of Clock Enable Register
  ptr_GPIOA_MODER = (uint32_t *)0x40020000; // Address of GPIO Port A Mode Register
  ptr_GPIOB_MODER = (uint32_t *)0x40020400; // Address of GPIO Port B Mode Register
  ptr_GPIOC_MODER = (uint32_t *)0x40020800; // Address of GPIO Port C Mode Register
  ptr_GPIOA_IDR = (uint32_t *)0x40020010;   // Address of GPIO Port A Input Data Register
  ptr_GPIOB_IDR = (uint32_t *)0x40020410;   // Address of GPIO Port B Input Data Register
  ptr_GPIOB_ODR = (uint32_t *)0x40020414;   // Address of GPIO Port B Output Data Register
  ptr_GPIOC_ODR = (uint32_t *)0x40020814;   // Address of GPIO Port C Output Data Register
}

void config()
{
  *ptr_AHB1ENR |= (1 << 0) | (1 << 1) | (1 << 2); // Enable clock for GPIO Port A, B, and C

  *ptr_GPIOA_MODER &= ~(3 << 30);                         // Set PA15 to input mode (SW4)
  *ptr_GPIOB_MODER &= ~((3 << 6) | (3 << 8) | (3 << 14)); // Set PB3, PB4, and PB7 to input mode (SW2, SW3, and SW1)

  *ptr_GPIOC_MODER |= (1 << 12); // Set PC6 to output mode (LED1)
  *ptr_GPIOC_MODER &= ~(1 << 13);
  *ptr_GPIOB_MODER |= (1 << 26); // Set PB13 to output mode (LED2)
  *ptr_GPIOB_MODER &= ~(1 << 27);
  *ptr_GPIOB_MODER |= (1 << 28); // Set PB14 to output mode (LED3)
  *ptr_GPIOB_MODER &= ~(1 << 29);
  *ptr_GPIOB_MODER |= (1 << 30); // Set PB15 to output mode (LED4)
  *ptr_GPIOB_MODER &= ~(1 << 31);

  *ptr_GPIOC_MODER |= (1 << 18); // Set PC9 to output mode (Buzzer)
  *ptr_GPIOC_MODER &= ~(1 << 19);
}

void start()
{
  while (1)
  {
    if ((*ptr_GPIOA_IDR & (1 << 15)) == 0) // If SW4 is pressed
    {
      set_led(4);
      toggle_buzzer(1);
      delay(10);
      toggle_buzzer(0);
      delay(100);
    }
    else if ((*ptr_GPIOB_IDR & (1 << 3)) == 0) // If SW2 is pressed
    {
      set_led(2);
      toggle_buzzer(1);
      delay(10);
      toggle_buzzer(0);
      delay(100);
    }
    else if ((*ptr_GPIOB_IDR & (1 << 4)) == 0) // If SW3 is pressed
    {
      set_led(3);
      toggle_buzzer(1);
      delay(10);
      toggle_buzzer(0);
      delay(100);
    }
    else if ((*ptr_GPIOB_IDR & (1 << 7)) == 0) // If SW1 is pressed
    {
      set_led(1);
      toggle_buzzer(1);
      delay(10);
      toggle_buzzer(0);
      delay(100);
    }
  }
}

void set_led(uint8_t led)
{
  switch (led)
  {
  case 1:
    *ptr_GPIOC_ODR ^= (1 << 6); // Turn on LED1
    break;
  case 2:
    *ptr_GPIOB_ODR ^= (1 << 15); // Turn on LED2
    break;
  case 3:
    *ptr_GPIOB_ODR ^= (1 << 14); // Turn on LED3
    break;
  case 4:
    *ptr_GPIOB_ODR ^= (1 << 13); // Turn on LED4
    break;
  default:
    break;
  }
}

void toggle_buzzer(uint8_t buzzer_state)
{
  if (buzzer_state == 0)
  {
    *ptr_GPIOC_ODR &= ~(1 << 9);
  }
  else
  {
    *ptr_GPIOC_ODR |= (1 << 9);
  }
}

void delay(uint32_t delay_ms)
{
  uint32_t counter;
  for (counter = 0; counter < delay_ms * 1000; counter++)
    ;
}
