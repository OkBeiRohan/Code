/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : USART communication
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <common.h>

#define TIM_FREQ 16000000

void config_usart(void);
void usart_write(uint8_t);
uint8_t usart_read(void);

int main(void)
{
    uint8_t data = 0;

    lcd_init(BIT_4_MODE);
    config_usart();
    lcd_print(0, 0, "USART Data");
    lcd_print(0, 1, "Check Terminal");

    while (1)
    {
        usart_write('H');
        data = usart_read();
        lcd_print(0, 1, (char *)data);
        usart_write('e');
        usart_write('l');
        usart_write('l');
        usart_write('o');
        usart_write(' ');
        usart_write('W');
        usart_write('o');
        usart_write('r');
        usart_write('l');
        usart_write('d');
        usart_write('!');
        usart_write('\n');
    }
}

void config_usart(void)
{
    RCC->APB1ENR |= (1 << 18); // Enable USART3 clock
    RCC->AHB1ENR |= (1 << 2);  // Enable GPIOC clock

    set_alternate(GPIOC, 10); // Set PC10 to alternate function
    set_alternate(GPIOC, 11); // Set PC11 to alternate function

    // Set alternate function to USART2
    GPIOC->AFR[1] &= ~(0xF << 8);  // Clear AFRH8
    GPIOC->AFR[1] &= ~(0xF << 12); // Clear AFRH12
    GPIOC->AFR[1] |= (0x7 << 8);   // Set AFRH8 to AF7
    GPIOC->AFR[1] |= (0x7 << 12);  // Set AFRH12 to AF7

    // Set USART2 to 9600 baud, 8 data bits, 1 stop bit, no parity
    USART3->BRR = 0x0683;      // TIM_FREQ / 9600;
    USART3->CR1 |= (0xC << 0); // Enable receiver
    USART3->CR2 = 0;           // Enable transmitter
    USART3->CR3 = 0;           // No flow control
    USART3->CR1 |= (1 << 13);  // Enable USART2
}

void usart_write(uint8_t data)
{
    while (!(USART2->SR & (1 << 7)))
    {
    }
    USART2->DR = data;
}

uint8_t usart_read(void)
{
    while (!(USART2->SR & (1 << 5)))
    {
    }
    return USART2->DR;
}