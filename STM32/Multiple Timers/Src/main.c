/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Timer delay
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <lcd.h>

uint32_t volatile *ptr_NVIC_IRQ_EN = (uint32_t *)0xE000E100;

void timer2_enable();
void timer2_disable();
void timer3_enable();
void timer3_disable();
void seconds_increment(uint8_t);
void check_button();
void init();

char seconds[2][4] = {"000", "000"};
uint8_t t2 = 0, t3 = 0;

int main(void)
{
    init();

    while (1)
    {
        check_button();
    }
}

void init()
{
    lcd_init(BIT_4_MODE);
    lcd_print(0, 0, "Timer Init");
    lcd_print(0, 1, "Please Wait!");

    RCC->APB1ENR |= (1 << 0); // Enable clock for TIM2
    TIM2->PSC = 16000 - 1;    // Set prescaler to 16000
    TIM2->ARR = 1000 - 1;     // Set auto-reload register to 1000
    TIM2->CNT = 0;            // Set counter to 0
    TIM2->DIER |= (1 << 0);   // Enable interrupt for TIM2

    RCC->APB1ENR |= (1 << 1); // Enable clock for TIM3
    TIM3->PSC = 16000 - 1;    // Set prescaler to 16000
    TIM3->ARR = 1000 - 1;     // Set auto-reload register to 1000
    TIM3->CNT = 0;            // Set counter to 0
    TIM3->DIER |= (1 << 0);   // Enable interrupt for TIM3

    *ptr_NVIC_IRQ_EN |= (1 << 28); // Enable interrupt for TIM2
    *ptr_NVIC_IRQ_EN |= (1 << 29); // Enable interrupt for TIM3

    /**
     * SW4 and Sw3 in input mode
     */
    RCC->AHB1ENR |= (1 << 0);   // Enable clock for GPIO Port A
    GPIOA->MODER &= ~(3 << 30); // Set PA15 to input mode (SW4)

    RCC->AHB1ENR |= (1 << 1);  // Enable clock for GPIO Port B
    GPIOB->MODER &= ~(3 << 6); // Set PB3 to input mode (SW3)

    set_lcd_mode(CLEAR_SCREEN);
    lcd_print(0, 0, "Timer2    Timer3");
    lcd_print(4, 1, "s");
    lcd_print(14, 1, "s");
}

void check_button()
{
    if (!(GPIOA->IDR & (1 << 15)))
    {
        while (!(GPIOA->IDR & (1 << 15)))
            ; // Wait until SW4 is released
        if (t2 == 0)
        {
            t2 = 1;
            timer2_enable();
        }
        else
        {
            t2 = 0;
            timer2_disable();
        }
    }
    if (!(GPIOB->IDR & (1 << 3)))
    {
        while (!(GPIOB->IDR & (1 << 3)))
            ; // Wait until SW3 is released
        if (t3 == 0)
        {
            t3 = 1;
            timer3_enable();
        }
        else
        {
            t3 = 0;
            timer3_disable();
        }
    }
}

void seconds_increment(uint8_t timer)
{
    seconds[timer][2]++;
    if (seconds[timer][2] == '9' + 1)
    {
        seconds[timer][2] = '0';
        seconds[timer][1]++;
        if (seconds[timer][1] == '9' + 1)
        {
            seconds[timer][1] = '0';
            seconds[timer][0]++;
            if (seconds[timer][0] == '9' + 1)
            {
                seconds[timer][0] = '0';
            }
        }
    }
    if (timer == 0)
    {
        lcd_print(0, 1, seconds[timer]);
    }
    else
    {
        lcd_print(10, 1, seconds[timer]);
    }
}

void timer2_enable()
{
    TIM2->CR1 |= (1 << 0); // Enable timer
}

void TIM2_IRQHandler()
{
    TIM2->SR &= ~(1 << 0); // Clear interrupt flag
    seconds_increment(0);
}

void TIM3_IRQHandler()
{
    TIM3->SR &= ~(1 << 0); // Clear interrupt flag
    seconds_increment(1);
}

void timer2_disable()
{
    TIM2->CR1 &= ~(1 << 0); // Disable timer
    TIM2->SR &= ~(1 << 0);  // Clear UIF flag
}

void timer3_enable()
{
    TIM3->CR1 |= (1 << 0); // Enable timer
}

void timer3_disable()
{
    TIM3->CR1 &= ~(1 << 0); // Disable timer
    TIM3->SR &= ~(1 << 0);  // Clear UIF flag
}
