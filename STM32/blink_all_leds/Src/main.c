/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Blink All LEDs As Binary Counter and Produce a sound
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 ******************************************************************************
 * Program to blink all on-board LEDs (PC6, PB13, PB14, PB15) as a binary counter.
 */

#include <stdint.h>

void blink_led(uint32_t *, uint32_t *);
void trigger_buzzer(uint32_t *);
void delay(uint32_t);

int main(void)
{
  /**
   * To blink LED, enable the clock for the General Purpose I/O (GPIO) ports C and B.
   * Base address of the clock enable register (RCC_AHB1ENR) = 0x4002 3800
   * Offset address = 0x30
   * Address = 0x4002 3830
   * For LED1, Port PC6 have to be enabled. For that enable GPIOCEN bit. (At 2nd position)
   * For LED2, LED3, and LED4, Port PB13, PB14, and PB15 have to be enabled. For that enable GPIOBEN bit. (At 1st position)
   */
  uint32_t *ptr_RCC_AHB1ENR = (uint32_t *)0x40023830;
  *ptr_RCC_AHB1ENR |= (1 << 2); // Set bit 2 (GPIOCEN)
  *ptr_RCC_AHB1ENR |= (1 << 1); // Set bit 1 (GPIOBEN)

  /**
   * Set the mode of the pin PC9 to output mode. (For buzzer)
   * Base address of the GPIO Port C Mode Register (GPIOC) = 0x4002 0800
   * Offset address of the mode register = 0x00
   * Address = 0x4002 0800
   * For buzzer, Pin PC6 have to be set to output mode. For that set GPIOC6 bit. (At 12th position)
   * Output Mode = 01
   */
  uint32_t *ptr_GPIOC_MODER = (uint32_t *)0x40020800;
  *ptr_GPIOC_MODER |= (1 << 18);  // Set bit 18
  *ptr_GPIOC_MODER &= ~(1 << 19); // Clear bit 19

  /**
   * Set the mode of the pins PC6, PB13, PB14, and PB15 to output mode.
   * Base address of the GPIO Port C Mode Register (GPIOC) = 0x4002 0800
   * Offset address of the mode register = 0x00
   * Address = 0x4002 0800
   * For LED1, Pin PC6 have to be set to output mode. For that set GPIOC6 bit. (At 12th position)
   *
   * Base address of the GPIO Port B Mode Register (GPIOB) = 0x4002 0400
   * For LED2, Pin PB13 have to be set to output mode. For that set GPIOB13 bit. (At 26th position)
   * For LED3, Pin PB14 have to be set to output mode. For that set GPIOB14 bit. (At 28th position)
   * For LED4, Pin PB15 have to be set to output mode. For that set GPIOB15 bit. (At 30th position)
   *
   * Output Mode = 01
   */
  uint32_t *ptr_GPIOC_MODER = (uint32_t *)0x40020800;
  *ptr_GPIOC_MODER |= (1 << 12);  // Set bit 12
  *ptr_GPIOC_MODER &= ~(1 << 13); // Clear bit 13

  uint32_t *ptr_GPIOB_MODER = (uint32_t *)0x40020400;
  *ptr_GPIOB_MODER |= (1 << 26);  // Set bit 26
  *ptr_GPIOB_MODER &= ~(1 << 27); // Clear bit 27
  *ptr_GPIOB_MODER |= (1 << 28);  // Set bit 28
  *ptr_GPIOB_MODER &= ~(1 << 29); // Clear bit 29
  *ptr_GPIOB_MODER |= (1 << 30);  // Set bit 30
  *ptr_GPIOB_MODER &= ~(1 << 31); // Clear bit 31

  /**
   * Change the output bit through the port PC6 using the Output Data Register (ODR) (For buzzer)
   * Base address of the GPIO port C = 0x4002 0800
   * Offset address of the mode register = 0x14
   * Address = 0x4002 0814
   * For turning the buzzer ON, reset the ODR6 bit. For turning it OFF, set the ODR6 bit
   */
  uint32_t *ptr_GPIOC_ODR = (uint32_t *)0x40020814;

  /**
   * Change the output bit through the ports using the Output Data Register (ODR)
   * Base address of the GPIO port C = 0x4002 0800
   * Base address of the GPIO port B = 0x4002 0400
   * Offset address of the mode register = 0x14
   * Address for port C= 0x4002 0814
   * Address for port B= 0x4002 0414
   * For turning the LED ON, reset the ODR6 bit. For turning it OFF, set the ODR6 bit
   */
  uint32_t *ptr_GPIOC_ODR = (uint32_t *)0x40020814;
  uint32_t *ptr_GPIOB_ODR = (uint32_t *)0x40020414;

  blink_led(ptr_GPIOC_ODR, ptr_GPIOB_ODR);
}

/**
 * Function to blink the LED
 * @param ptr_GPIOC_ODR Pointer to the GPIOC_ODR register
 * @param ptr_GPIOB_ODR Pointer to the GPIOB_ODR register
 * @return None
 */
void blink_led(uint32_t *ptr_GPIOC_ODR, uint32_t *ptr_GPIOB_ODR)
{
  uint8_t led_pattern = 0x00;

  /**
   * Initializing Sound
   */
  trigger_buzzer(ptr_GPIOC_ODR);
  delay(100);
  trigger_buzzer(ptr_GPIOC_ODR);
  delay(500);
  trigger_buzzer(ptr_GPIOC_ODR);
  delay(100);
  trigger_buzzer(ptr_GPIOC_ODR);

  /**
   * Blink LEDs indefinitely
   */
  while (1)
  {
    /**
     * Trigger the buzzer
     */
    trigger_buzzer(ptr_GPIOC_ODR);
    delay(100);
    trigger_buzzer(ptr_GPIOC_ODR);

    if (led_pattern & (0x01 << 0))
    {
      *ptr_GPIOC_ODR &= ~(0x01 << 6); // Turn LED1 ON
    }
    else
    {
      *ptr_GPIOC_ODR |= (0x01 << 6); // Turn LED1 OFF
    }

    if (led_pattern & (0x01 << 1))
    {
      *ptr_GPIOB_ODR &= ~(0x01 << 15); // Turn LED2 ON
    }
    else
    {
      *ptr_GPIOB_ODR |= (0x01 << 15); // Turn LED2 OFF
    }

    if (led_pattern & (0x01 << 2))
    {
      *ptr_GPIOB_ODR &= ~(0x01 << 14); // Turn LED3 ON
    }
    else
    {
      *ptr_GPIOB_ODR |= (0x01 << 14); // Turn LED3 OFF
    }

    if (led_pattern & (0x01 << 3))
    {
      *ptr_GPIOB_ODR &= ~(0x01 << 13); // Turn LED4 ON
    }
    else
    {
      *ptr_GPIOB_ODR |= (0x01 << 13); // Turn LED4 OFF
    }

    led_pattern++;

    delay(1000);
  }
}

/**
 * Function to trigger the buzzer
 * @param ptr_GPIOC_ODR Pointer to the GPIOC_ODR register
 * @return None
 */
void trigger_buzzer(uint32_t *ptr_GPIOC_ODR)
{
  if (*ptr_GPIOC_ODR & ~(1 << 9))
  {
    *ptr_GPIOC_ODR &= ~(1 << 9);
  }
  else
  {
    *ptr_GPIOC_ODR |= (1 << 9);
  }
}

/**
 * Function to generate delay
 * @param delay_ms Delay in milliseconds
 * @return None
 */
void delay(uint32_t delay_ms)
{
  uint32_t counter;
  for (counter = 0; counter < (delay_ms * 1000); counter++)
    ;
}
